/**
 * Telegram Bot - Main Entry Point
 * This file orchestrates the bot's initialization, middleware, and handlers.
 */

require('dotenv').config();
const { Telegraf, session } = require('telegraf');
const path = require('path');
const lockfile = require('proper-lockfile');

// Core Services
const logger = require('./utils/logger.util');
const dbService = require('./services/database.service');

// Middleware
const { loggerMiddleware } = require('./middleware/logger.middleware');
const { authMiddleware, permissionMiddleware } = require('./middleware/auth.middleware');

// Handlers
const { handleStart } = require('./handlers/start.handler.js');
const joinRequestHandler = require('./handlers/join-request.handler.js');
const approveRequestsHandler = require('./handlers/approve-requests.handler.js');
// ... other handlers

// Initialize bot
const bot = new Telegraf(process.env.BOT_TOKEN);

async function initialize() {
  try {
    logger.info('Initializing database...', 'Bootstrap');
    await dbService.initialize();
    logger.info('Database initialized.', 'Bootstrap');

    const botInfo = await bot.telegram.getMe();
    logger.info(`Bot starting as @${botInfo.username}`, 'Bootstrap');
  } catch (error) {
    logger.error('Bot initialization failed:', 'Bootstrap', error);
    process.exit(1);
  }
}

function registerMiddleware() {
  logger.info('Registering middleware...', 'Bootstrap');
  bot.use(session()); // Needed for conversation-based workflows
  bot.use(loggerMiddleware);
  bot.use(authMiddleware); // Handles user identification
  bot.use(permissionMiddleware); // Handles command permissions
}

function registerHandlers() {
  logger.info('Registering handlers...', 'Bootstrap');

  // Command Handlers
  bot.command('start', handleStart);
  bot.command('requests', approveRequestsHandler.handleRequestsCommand);

  // Callback Query Handlers (for inline buttons)
  bot.action('workflow:join_request', (ctx) => joinRequestHandler.startWorkflow(ctx));
  bot.action(/^workflow:join_request:(confirm|cancel)$/, (ctx) => joinRequestHandler.handleCallback(ctx));
  bot.action(/^request:(approve|reject):\d+$/, (ctx) => approveRequestsHandler.handleCallback(ctx));

  // Text Message Handler (for workflow steps)
  bot.on('text', async (ctx, next) => {
    // If the message is a command, skip this handler
    if (ctx.message.text.startsWith('/')) return next();

    const state = await dbService.getConversationState(ctx.from.id);
    if (state && state.workflow_id === 'join_request') {
      await joinRequestHandler.handleStep(ctx, state);
    } else {
      // Not in a workflow, proceed to other handlers (like unknown command)
      return next();
    }
  });

  // Fallback for unknown commands
  bot.on('message', (ctx) => {
    logger.warn(`Unhandled message type or unknown command: "${ctx.message.text}"`, 'Handler');
    ctx.reply(`Sorry, I didn't understand that command.`);
  });
}

async function start() {
  const lockPath = path.join(__dirname, '../data');
  try {
    await lockfile.lock(lockPath, { lockfilePath: path.join(lockPath, 'bot.lock'), retries: 0 });
    logger.info('Lock acquired. Starting bot...', 'Bootstrap');

    await initialize();
    registerMiddleware();
    registerHandlers();

    // Graceful shutdown
    process.once('SIGINT', () => bot.stop('SIGINT'));
    process.once('SIGTERM', () => bot.stop('SIGTERM'));

    await bot.launch();
    logger.info('Bot is running.', 'Bootstrap');

  } catch (error) {
    if (error.code === 'ELOCKED') {
      logger.error('Another instance is already running. Exiting.', 'Bootstrap');
    } else {
      logger.error('Failed to start bot:', 'Bootstrap', error);
    }
    process.exit(1);
  }
}

start();
