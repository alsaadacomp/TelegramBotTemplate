/**
 * ====================================
 * Permission Service
 * ====================================
 * Manages user roles, permissions, and join requests.
 *
 * @module services/permission
 */

const permissionsConfig = require('../../config/permissions.config');
const dbService = require('./database.service');
const cacheService = require('./cache.service');
const logger = require('../utils/logger.util');

class PermissionService {
  constructor() {
    this.dbService = dbService;
    this.cacheService = cacheService;
  }

  /**
   * Checks if a user's role has a specific permission.
   * @param {string} roleName - The name of the role (e.g., 'admin').
   * @param {string} permission - The permission string (e.g., 'general.menu').
   * @returns {Promise<boolean>}
   */
  async hasPermission(roleName, permission) {
    const cacheKey = `role:${roleName}:${permission}`;
    const cachedResult = this.cacheService.get('permissions', cacheKey);
    if (cachedResult !== undefined) {
      return cachedResult;
    }

    const hasPerm = permissionsConfig.hasPermission(roleName, permission);
    this.cacheService.set('permissions', cacheKey, hasPerm, 3600); // Cache for 1 hour
    return hasPerm;
  }

  /**
   * Gets the role for a given user.
   * @param {number} telegramId - The user's Telegram ID.
   * @returns {Promise<string>}
   */
  async getUserRole(telegramId) {
    const cacheKey = `user:${telegramId}:role`;
    const cachedRole = this.cacheService.get('users', cacheKey);
    if (cachedRole) {
      return cachedRole;
    }

    const user = await this.dbService.getUserByTelegramId(telegramId);
    const role = user ? user.role : permissionsConfig.ROLES.VISITOR;

    this.cacheService.set('users', cacheKey, role, 900); // Cache for 15 minutes
    return role;
  }

  /**
   * Assigns a new role to a user.
   * @param {number} telegramId - The ID of the user to update.
   * @param {string} newRole - The new role to assign.
   * @param {number} adminId - The ID of the admin performing the action.
   */
  async assignRole(telegramId, newRole, adminId) {
    if (!Object.values(permissionsConfig.ROLES).includes(newRole)) {
      throw new Error(`Invalid role: ${newRole}`);
    }

    const user = await this.dbService.getUserByTelegramId(telegramId);
    if (!user) {
      throw new Error(`User with ID ${telegramId} not found.`);
    }

    await this.dbService.updateUser(telegramId, { role: newRole });
    this.invalidateUserCache(telegramId);

    logger.info(`Role for user ${telegramId} changed to ${newRole} by admin ${adminId}.`, 'Permission');
    await this.dbService.logAction({
      user_id: adminId,
      action: 'ROLE_CHANGE',
      metadata: JSON.stringify({ target_user_id: telegramId, new_role: newRole }),
    });
  }

  /**
   * Creates a new join request in the database.
   * @param {object} requestData - Data for the join request.
   * @returns {Promise<object>}
   */
  async createJoinRequest(requestData) {
    const result = await this.dbService.run(
      'INSERT INTO join_requests (telegram_id, username, first_name, last_name, full_name, phone) VALUES (?, ?, ?, ?, ?, ?)',
      [requestData.telegram_id, requestData.username, requestData.first_name, requestData.last_name, requestData.full_name, requestData.phone]
    );
    logger.info(`New join request created for user ${requestData.telegram_id} with ID ${result.lastID}`, 'Permission');
    return { id: result.lastID, ...requestData };
  }

  /**
   * Retrieves all pending join requests.
   * @returns {Promise<Array<object>>}
   */
  async getPendingRequests() {
    return this.dbService.all("SELECT * FROM join_requests WHERE status = 'pending' ORDER BY requested_at ASC");
  }

  /**
   * Approves a join request.
   * @param {number} requestId - The ID of the join request.
   * @param {number} adminId - The ID of the super_admin who approved it.
   * @returns {Promise<object>}
   */
  async approveRequest(requestId, adminId) {
    const request = await this.dbService.get('SELECT * FROM join_requests WHERE id = ?', [requestId]);
    if (!request || request.status !== 'pending') {
      throw new Error('Request not found or already processed.');
    }

    // 1. Create or update the user
    let user = await this.dbService.getUserByTelegramId(request.telegram_id);
    const userData = {
      telegram_id: request.telegram_id,
      username: request.username,
      first_name: request.first_name,
      last_name: request.last_name,
      role: permissionsConfig.ROLES.ADMIN, // Assign ADMIN role
      status: 'active',
      join_request_id: requestId,
    };

    if (user) {
      await this.dbService.updateUser(request.telegram_id, userData);
    } else {
      await this.dbService.createUser(userData);
    }

    // 2. Update the request status
    await this.dbService.run(
      "UPDATE join_requests SET status = 'approved', reviewed_by = ?, reviewed_at = CURRENT_TIMESTAMP WHERE id = ?",
      [adminId, requestId]
    );

    this.invalidateUserCache(request.telegram_id);
    logger.info(`Join request ${requestId} approved by admin ${adminId}. User ${request.telegram_id} is now an admin.`, 'Permission');
    return request; // Return the original request for notification purposes
  }

  /**
   * Rejects a join request.
   * @param {number} requestId - The ID of the join request.
   * @param {number} adminId - The ID of the super_admin who rejected it.
   * @param {string} reason - The reason for rejection.
   * @returns {Promise<object>}
   */
  async rejectRequest(requestId, adminId, reason) {
    const request = await this.dbService.get('SELECT * FROM join_requests WHERE id = ?', [requestId]);
    if (!request || request.status !== 'pending') {
      throw new Error('Request not found or already processed.');
    }

    await this.dbService.run(
      "UPDATE join_requests SET status = 'rejected', reviewed_by = ?, reviewed_at = CURRENT_TIMESTAMP, rejection_reason = ? WHERE id = ?",
      [adminId, reason, requestId]
    );

    logger.info(`Join request ${requestId} rejected by admin ${adminId}.`, 'Permission');
    return request;
  }

  /**
   * Invalidates all caches related to a user.
   * @param {number} telegramId - The user's Telegram ID.
   */
  invalidateUserCache(telegramId) {
    const id = String(telegramId);
    this.cacheService.delete('users', `user:${id}:role`);
    this.cacheService.deleteWithPrefix('permissions', `role:${id}`);
    logger.debug(`Cache invalidated for user ${id}.`, 'Permission');
  }
}

// Export a singleton instance
const instance = new PermissionService();
module.exports = instance;
